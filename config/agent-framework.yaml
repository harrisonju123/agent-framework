# Agent Framework Configuration
# Copy this file to agent-framework.yaml and customize as needed

workspace: "."
communication_dir: ".agent-communication"

# LLM Configuration
llm:
  # Mode: "claude_cli" (Claude Code subprocess) or "litellm" (API calls)
  mode: claude_cli

  # Proxy: route Claude CLI API calls through LiteLLM proxy for billing/routing
  # Only applies when mode: claude_cli
  # proxy_url: ${LITELLM_PROXY_URL}
  # proxy_auth_token: ${LITELLM_AUTH_TOKEN}

  # Claude CLI settings (used when mode=claude_cli)
  claude_cli_executable: claude
  claude_cli_max_turns: 999
  claude_cli_timeout: 3600  # Default fallback timeout (1 hour)

  # Task-type-specific timeouts (prevents vague tasks from running too long)
  # Large: IMPLEMENTATION, ARCHITECTURE, ANALYSIS, PLANNING, ESCALATION, ENHANCEMENT
  # Bounded: TESTING, VERIFICATION, FIX, BUGFIX, REVIEW, PR_REQUEST
  # Simple: DOCUMENTATION, COORDINATION, STATUS_REPORT
  claude_cli_timeout_large: 3600   # 1 hour
  claude_cli_timeout_bounded: 1800 # 30 minutes
  claude_cli_timeout_simple: 900   # 15 minutes

  claude_cli_cheap_model: claude-haiku-4-5-20251001
  claude_cli_default_model: claude-sonnet-4-5-20250929
  claude_cli_premium_model: claude-sonnet-4-5-20250929

  # LiteLLM direct settings (used when mode=litellm)
  # pip install 'agent-framework[litellm]' required
  # litellm_api_key: ${LITELLM_API_KEY}
  # litellm_api_base: ${LITELLM_API_BASE}
  # litellm_cheap_model: claude-haiku-4-5-20251001
  # litellm_default_model: claude-sonnet-4-5-20250929
  # litellm_premium_model: claude-sonnet-4-5-20250929

  # MCP (Model Context Protocol) settings
  # Enables real-time JIRA/GitHub access during agent execution
  # Requires mode: claude_cli
  use_mcp: true
  mcp_config_path: config/mcp-config.json

# Task Processing Configuration
task:
  poll_interval: 30          # Queue polling interval (seconds)
  timeout: 3600              # Task timeout (seconds, default: 1 hour)
  max_retries: 5             # Max retry attempts before escalation
  backoff_initial: 30        # Initial backoff delay (seconds)
  backoff_max: 240           # Max backoff delay (seconds)
  backoff_multiplier: 2      # Backoff multiplier (exponential)

  # Task validation (prevents vague/underspecified tasks from processing)
  # Only validates agent-generated tasks; JIRA tickets are skipped
  validate_tasks: true
  validation_mode: warn      # "warn" logs warning, "reject" fails the task

# Safeguards Configuration
safeguards:
  max_queue_size: 100        # Max tasks per agent queue
  max_escalations: 50        # Max total escalations
  max_task_age_days: 7       # Archive tasks older than N days
  heartbeat_timeout: 600     # Agent considered dead after N seconds (10 min for long MCP tasks)
  watchdog_interval: 60      # Watchdog check interval (seconds)

# Optimization Configuration
# Token usage optimizations for reducing prompt size and costs
optimization:
  # Quick wins (Phase 1)
  enable_minimal_prompts: false           # Strategy 1: Reduce task JSON to essential fields only
  enable_compact_json: false              # Strategy 4: Remove whitespace from JSON in prompts
  enable_context_deduplication: false     # Strategy 3: Eliminate description/context duplication

  # Structural changes (Phase 2)
  enable_token_tracking: false            # Strategy 6: Track token usage per task
  enable_token_budget_warnings: false     # Strategy 6: Warn when tasks exceed budget

  # Advanced features (Phase 3)
  enable_result_summarization: false      # Strategy 5: Extract and reuse task outcomes
  enable_error_truncation: false          # Strategy 8: Truncate large error messages

  # Rollout settings
  canary_percentage: 0  # 0-100, percentage of tasks to use optimizations (0=disabled, 100=all)
  shadow_mode: false    # If true, generate both prompts but use legacy (for validation)

  # Budget warning threshold (e.g., 1.3 = warn at 130% of budget)
  budget_warning_threshold: 1.3  # Default: warn at 30% over budget

  # Token budgets by task type (optional, uses sensible defaults if not specified)
  # Customize these if your tasks consistently need more/less tokens
  # token_budgets:
  #   planning: 30000
  #   implementation: 50000
  #   testing: 20000
  #   escalation: 80000
  #   review: 25000

# Session Logging: structured per-task logs for post-hoc analysis
# Captures prompt content, tool calls, memory ops, self-eval, replanning, etc.
# Output: logs/sessions/{task_id}.jsonl
session_logging:
  enabled: true
  log_prompts: true          # Include full prompt text (can be large)
  log_tool_inputs: true      # Include tool call parameters
  retention_days: 30         # Auto-cleanup old session logs

# Agent Memory: persistent cross-task learning
memory:
  enabled: true
  max_memories_per_store: 200     # Max entries per (repo, agent_type) pair
  max_prompt_chars: 3000          # Max chars of memory injected into prompts
  recency_half_life_days: 7       # Memories lose half relevance after N days

# Self-Evaluation: agents review their own output before marking done
self_evaluation:
  enabled: true
  max_retries: 2                  # Max self-eval retry loops before proceeding
  model: haiku                    # Cheap model for evaluation (haiku/sonnet)

# Dynamic Replanning: generate revised plans on retry 2+
replanning:
  enabled: true
  min_retry_for_replan: 2         # Start replanning at this retry count
  model: haiku                    # Cheap model for replanning

# Team mode: use Claude Agent Teams for multi-agent workflows
team_mode:
  enabled: true

# Multi-Repository Configuration
# Used by the 'agent apply-pattern' command
multi_repo:
  workspace_root: "~/.agent-workspaces"  # Where to clone repos for multi-repo operations

  # Git worktree configuration for isolated agent workspaces
  # Each parallel task gets its own worktree (separate branch, separate directory)
  worktree:
    enabled: true
    root: "~/.agent-workspaces/worktrees"
    cleanup_on_complete: true      # Remove worktree after successful task
    cleanup_on_failure: false      # Keep failed worktrees for debugging
    max_age_hours: 24              # Auto-cleanup worktrees older than this
    max_worktrees: 50              # Max concurrent worktrees (increase for parallel work)

# Repository Registry
# Repos are cloned to multi_repo.workspace_root (~/.agent-workspaces by default)
repositories:
  - github_repo: justworkshr/pto
    jira_project: PLUTO
    display_name: PTO Service

  - github_repo: justworkshr/international
    jira_project: INTL
    display_name: International Service

  - github_repo: justworkshr/sui
    jira_project: SUI
    display_name: Sui Service

  - github_repo: justworkshr/punch-out
    jira_project: PLUTO
    display_name: Punch Out Service

  - github_repo: justworkshr/mauvelous-hippo
    jira_project: ME
    display_name: Lifecycle Service

  - github_repo: justworkshr/clockwork_web
    jira_project: ME
    display_name: Clockwork Web

  - github_repo: harrisonju123/agent-framework
    jira_project: AF
    display_name: Agent Framework
# Workflow Configuration
# Supports both legacy linear format and new DAG format with conditional branches

workflows:
  # Legacy format (backward compatible): linear agent chain
  default:
    description: "Architect plans, Engineer implements, QA reviews, Architect creates PR"
    agents: [architect, engineer, qa]
    pr_creator: architect
    auto_review: true
    require_tests: true

  analysis:
    description: "Repository analysis workflow"
    agents: [architect]
    output: jira_epic
    auto_review: false
    require_tests: false

  # DAG format example: conditional branches and parallel paths
  # Uncomment to use DAG workflow instead of default linear chain
  # default:
  #   description: "Smart workflow with conditional branches"
  #   start_step: plan
  #   pr_creator: architect
  #   auto_review: true
  #   require_tests: true
  #   steps:
  #     plan:
  #       agent: architect
  #       next:
  #         - target: implement
  #     implement:
  #       agent: engineer
  #       next:
  #         - target: qa_review
  #     qa_review:
  #       agent: qa
  #       next:
  #         # Conditional branches based on QA result
  #         - target: create_pr
  #           condition: approved
  #           priority: 10
  #         - target: implement
  #           condition: needs_fix
  #           priority: 5
  #     create_pr:
  #       agent: architect
  #       # Terminal step (no next)
  #
  # Advanced DAG example with file-based skip paths:
  # smart_workflow:
  #   description: "Skip QA for docs-only changes"
  #   start_step: plan
  #   steps:
  #     plan:
  #       agent: architect
  #       next:
  #         - target: implement
  #     implement:
  #       agent: engineer
  #       next:
  #         # Skip QA if only docs changed
  #         - target: create_pr
  #           condition: files_match
  #           params:
  #             pattern: "*.md"
  #           priority: 10
  #         # Skip QA for small changes
  #         - target: create_pr
  #           condition: pr_size_under
  #           params:
  #             max_files: 3
  #           priority: 5
  #         # Default: go to QA
  #         - target: qa_review
  #           condition: always
  #     qa_review:
  #       agent: qa
  #       next:
  #         - target: create_pr
  #           condition: approved
  #         - target: implement
  #           condition: needs_fix
  #     create_pr:
  #       agent: architect

# Circuit Breaker Configuration
# Orchestrator-level health checks to prevent cascading failures
circuit_breaker:
  enabled: true
  check_interval_seconds: 300  # Check health every 5 minutes
  thresholds:
    max_failure_rate: 0.30     # >30% task failures triggers degradation
    max_stuck_tasks: 10         # >10 stuck tasks triggers action
    max_escalations: 50         # >50 escalations indicates systemic issues
  actions:
    on_degraded: reduce_replicas   # Scale down agents on degradation
    on_critical: pause_intake      # Stop accepting new tasks on critical health

# Analytics Configuration
# Performance metrics, failure detection, and continuous improvement
analytics:
  enabled: true

  # Performance metrics collection
  performance_metrics:
    enabled: true
    report_interval_hours: 24      # Generate report every 24 hours
    retention_days: 30             # Keep metrics for 30 days

  # Failure pattern detection
  failure_detection:
    enabled: true
    pattern_threshold: 3           # Minimum occurrences to report a pattern
    analysis_interval_hours: 168   # Weekly analysis (168 hours)

  # Shadow mode optimization analysis
  shadow_mode_analysis:
    enabled: true
    min_samples: 10                # Minimum samples before recommendations
    safety_threshold: 0.02         # Max acceptable success rate drop (2%)

  # Dynamic token budget optimization
  dynamic_budgets:
    enabled: false                 # Start disabled, enable after baseline
    adjustment_interval_days: 7    # Recalculate budgets weekly
    percentile: 90                 # Use P90 for budget calculation
    min_samples: 20                # Minimum tasks before adjusting

  # Quality trend tracking
  quality_trends:
    enabled: true
    track_test_coverage: true
    track_static_analysis: true
    track_pr_revisions: true
